1.系统引入消息队列优点
解耦:上游系统不会因为下游系统调整自己的业务逻辑，比如订单系统的订单数据，下游系统可以差异性的消费数据，不用时也可以取消，订单系统无影响。
Pub/Sub 发布订阅消息这么一个模型，订单系统就跟其它系统彻底解耦了
削峰：高并发场景，比如秒杀，点赞等场景请求突然暴增，而服务器的处理资源是恒定的，很容易挂掉，于是用消息队列来缓冲瞬时流量
异步：使用消息队列将调用异步化，可改善网站的扩展性，使用消息队列将调用异步化，可改善网站的扩展性，还可改善网站系统的性能

2.缺点
系统可用性降低：系统引入的外部依赖越多，越容易挂掉
系统复杂度提高：怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已
一致性问题：A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了

3.为什么会有重复消息？如何保证幂等性？
以kafka为例，消费端宕掉，还没来得及提交offset,kafka不知道消费端消费到哪里，那么消费端就会从初始位置pull消息记录
这样就要求消费端要保证幂等性

幂等性：内存set或者redis标识，数据库唯一键（建立去重表），具体根据业务场景来

4.如何避免消息丢失？
Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：
0—表示不进行消息接收是否成功的确认；默认为0
1—表示当Leader接收成功时确认；
-1—表示Leader和Follower都接收成功时确认；

综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：
1）acks=0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失；
2）acks=1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；
ACK 机制
通过 ACK 机制保证消息送达。Kafka 采用的是至少一次（At least once），消息不会丢，但是可能会重复传输。
生产端：
为了得到更好的性能，Kafka 支持在生产者一侧进行本地buffer，也就是累积到一定的条数才发送，如果这里设置不当是会丢消息的。
生产者端设置 producer.type=async, sync，默认是 sync。
当设置为 async，会大幅提升性能，因为生产者会在本地缓冲消息，并适时批量发送。
如果对可靠性要求高，那么这里可以设置为 sync 同步发送。
消费端：
如果更注重可靠性，则需要显示提交 Offset，也就是当所有业务都处理完成的时候，再提交 Offset。这样会导致重复消费，需要提供幂等性接口。

5.顺序消息
1）一个topic 一个分区 一个消费者
2）N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。














